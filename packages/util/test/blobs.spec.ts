import { assert, describe, it } from 'vitest'

import { trustedSetup } from '@paulmillr/trusted-setups/fast-peerdas.js'
import { KZG as microEthKZG } from 'micro-eth-signer/kzg.js'
import {
  blobsToCellProofs,
  blobsToCellsAndProofs,
  blobsToCommitments,
  blobsToProofs,
  bytesToHex,
  commitmentsToVersionedHashes,
  computeVersionedHash,
  getBlobs,
} from '../src/index.ts'

const kzg = new microEthKZG(trustedSetup)

describe('getBlobs()', () => {
  it('should return an array of PrefixedHexString blobs', () => {
    const input = 'test input'
    const blobs = getBlobs(input)
    assert(Array.isArray(blobs))

    for (const blob of blobs) assert(typeof blob === 'string' && blob.slice(0, 2) === '0x')
  })

  it('should throw for invalid blob data', () => {
    const input = ''
    assert.throws(() => getBlobs(input), Error, 'invalid blob data')
  })

  it('should throw for too large blob data', () => {
    const input = 'a'.repeat(131072 * 6) // exceeds MAX_BLOB_BYTES_PER_TX * MAX_BLOBS_PER_TX
    assert.throws(() => getBlobs(input), Error, 'blob data is too large')
  })

  it('should allow for multiple inputs', () => {
    const input = ['test input', 'test input 2']
    const blobs = getBlobs(input)
    assert(Array.isArray(blobs))
    assert.lengthOf(blobs, 2)
    for (const blob of blobs) assert(typeof blob === 'string' && blob.slice(0, 2) === '0x')
  })
})

describe('computeVersionedHash()', () => {
  it('should return a versioned hash', () => {
    const commitment = new Uint8Array([1, 2, 3])
    const blobCommitmentVersion = 0x01
    const versionedHash = computeVersionedHash(bytesToHex(commitment), blobCommitmentVersion)
    assert(typeof versionedHash === 'string')
    assert.lengthOf(versionedHash, 66)
  })
})

describe('commitmentsToVersionedHashes()', () => {
  it('should return an array of versioned hashes', () => {
    const commitments = [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])]
    const blobVersionedHashes = commitmentsToVersionedHashes(
      commitments.map((com) => bytesToHex(com)),
    )
    assert(Array.isArray(blobVersionedHashes))

    for (const versionedHash of blobVersionedHashes) {
      assert(typeof versionedHash === 'string')
      assert.lengthOf(versionedHash, 66)
    }
  })
})

describe('blobsToProofs()', () => {
  it('should return an array of proofs', () => {
    const blobs = getBlobs(['0x01', '0x02'])
    const commitments = blobsToCommitments(kzg, blobs)
    const proofs = blobsToProofs(kzg, blobs, commitments)
    assert(Array.isArray(proofs))

    const expectedProofs = [
      '0x98994b1a2921d0eb16efc1fdc7f1edc0cecbe1d88194a5c2db6608996ebf20458c4230ab11e16863a9eefa02f654d5fa',
      '0x93a3260ab9a0fa5b7287f9b21397cf141595aada6f4a5a2c0876858a3df039ad7540b58b6e472fe19f3d40f19605e94f',
    ]
    assert.deepEqual(proofs, expectedProofs)
    assert.lengthOf(proofs, 2)
  })
})

describe('blobsToCellsAndProofs()', () => {
  it('should return an array of cells and proofs', () => {
    const blobs = getBlobs(['0x01', '0x02'])
    const cellsAndProofs = blobsToCellsAndProofs(kzg, blobs)
    assert(Array.isArray(cellsAndProofs))

    const expectedCell0 =
      '0x0000000000000000000000000000000000000000000000000000008031307830000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
    const expectedProof0 =
      '0x825ce2ddc755c5b43974ece42fb2fad0b6105019f10b7dd98a1330b01019a2f3d9d6daf08c9958858dc2ee0086ca106c'
    const expectedIndex0 = 0
    assert.deepEqual(cellsAndProofs[0][0], expectedCell0)
    assert.deepEqual(cellsAndProofs[1][0], expectedProof0)
    assert.deepEqual(cellsAndProofs[2][0], expectedIndex0)
    assert.lengthOf(cellsAndProofs, 3)
  }, 40000)
})

describe('blobsToCellProofs()', () => {
  it('should return an array of cell proofs', () => {
    const blobs = getBlobs(['0x01', '0x02'])
    const proofs = blobsToCellProofs(kzg, blobs)
    assert(Array.isArray(proofs))

    const expectedProof0 =
      '0x825ce2ddc755c5b43974ece42fb2fad0b6105019f10b7dd98a1330b01019a2f3d9d6daf08c9958858dc2ee0086ca106c'
    assert.deepEqual(proofs[0], expectedProof0)
    assert.lengthOf(proofs, 256)
  }, 40000)
})
